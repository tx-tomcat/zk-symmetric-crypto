import { Base64 } from 'js-base64'
import { CONFIG } from './config'
import { EncryptionAlgorithm, GenerateProofOpts, Proof, VerifyProofOpts } from './types'
import { getCounterForChunk } from './utils'

/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 */
export async function generateProof(opts: GenerateProofOpts): Promise<Proof> {
	const { algorithm, operator, logger } = opts
	const {
		bitsPerWord,
		chunkSize,
		bitsToUint8Array
	} = CONFIG[algorithm]
	const witness = await generateZkWitness(opts)
	const {
		proof,
		publicSignals
	} = await operator.groth16Prove(witness, logger)

	const totalBits = chunkSize * bitsPerWord

	return {
		algorithm,
		proofJson: typeof proof === 'string'
			? proof
			: JSON.stringify(proof),
		plaintext: Array.isArray(publicSignals) ? //snarkJS
			bitsToUint8Array(
				publicSignals
					.slice(0, totalBits)
					.map((x) => +x)
			) :
			Base64.toUint8Array(publicSignals) // gnark
	}
}

/**
 * Generate a ZK witness for the symmetric encryption circuit.
 * This witness can then be used to generate a ZK proof,
 * using the operator's groth16Prove function.
 */
export async function generateZkWitness({
	algorithm,
	privateInput: {
		key,
	},
	publicInput: { ciphertext, iv, offset },
	operator
}: GenerateProofOpts,
) {
	const {
		keySizeBytes,
		ivSizeBytes,
		isLittleEndian,
		uint8ArrayToBits,
	} = CONFIG[algorithm]
	if(key.length !== keySizeBytes) {
		throw new Error(`key must be ${keySizeBytes} bytes`)
	}

	if(iv.length !== ivSizeBytes) {
		throw new Error(`iv must be ${ivSizeBytes} bytes`)
	}

	const startCounter = getCounterForChunk(algorithm, offset)
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext,
	)
	const witness = await operator.generateWitness({
		key: uint8ArrayToBits(key),
		nonce: uint8ArrayToBits(iv),
		counter: serialiseCounter(),
		in: uint8ArrayToBits(ciphertextArray),
	},)
	return witness

	function serialiseCounter() {
		const counterArr = new Uint8Array(4)
		const counterView = new DataView(counterArr.buffer)
		counterView.setUint32(0, startCounter, isLittleEndian)

		const counterBits = uint8ArrayToBits(counterArr)
			.flat()
		return counterBits
	}
}

/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
export async function verifyProof({
	proof: { algorithm, plaintext, proofJson },
	publicInput: { ciphertext, iv, offset },
	operator,
}: VerifyProofOpts): Promise<void> {
	const { uint8ArrayToBits, isLittleEndian, startCounter } = CONFIG[algorithm]
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext
	)
	if(ciphertextArray.length !== plaintext.length) {
		throw new Error('ciphertext and plaintext must be the same length')
	}

	// serialise to array of numbers for the ZK circuit
	const pubInputs = [
		...uint8ArrayToBits(plaintext),
		...uint8ArrayToBits(iv),
		...serialiseCounter(),
		...uint8ArrayToBits(ciphertextArray),
	].flat()
	const verified = await operator.groth16Verify(
		pubInputs,
		JSON.parse(proofJson),
	)

	if(!verified) {
		throw new Error('invalid proof')
	}

	function serialiseCounter() {
		const counterArr = new Uint8Array(4)
		const counterView = new DataView(counterArr.buffer)
		counterView.setUint32(0, offset + startCounter, isLittleEndian)
		return uint8ArrayToBits(counterArr)
			.flat()
	}
}

function padCiphertextToChunkSize(
	alg: EncryptionAlgorithm,
	ciphertext: Uint8Array
) {
	const {
		chunkSize,
		bitsPerWord,
	} = CONFIG[alg]

	const expectedSizeBytes = (chunkSize * bitsPerWord) / 8
	if(ciphertext.length > expectedSizeBytes) {
		throw new Error(`ciphertext must be <= ${expectedSizeBytes}b`)
	}

	if(ciphertext.length < expectedSizeBytes) {
		const arr = new Uint8Array(expectedSizeBytes).fill(0)
		arr.set(ciphertext)

		ciphertext = arr
	}

	return ciphertext
}