import { CONFIG } from './config'
import { EncryptionAlgorithm, GenerateProofOpts, GenerateWitnessOpts, GetPublicSignalsOpts, Proof, VerifyProofOpts, ZKProofInput, ZKProofPublicSignals } from './types'
import { getCounterForChunk } from './utils'

/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 */
export async function generateProof(opts: GenerateProofOpts): Promise<Proof> {
	const { algorithm, operator, logger } = opts
	const { witness, plaintextArray } = await generateZkWitness(opts)
	let wtnsSerialised: Uint8Array
	if('mask' in opts) {
		wtnsSerialised = await operator.generateWitness({
			...witness,
			toprf: opts.toprf,
			mask: opts.mask,
		})
	} else {
		// @ts-expect-error
		wtnsSerialised = await operator.generateWitness(witness)
	}

	const { proof } = await operator.groth16Prove(wtnsSerialised, logger)

	return { algorithm, proofData: proof, plaintext: plaintextArray }
}

/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
export async function verifyProof(opts: VerifyProofOpts): Promise<void> {
	const publicSignals = getPublicSignals(opts)

	const { proof: { proofData }, operator, logger } = opts
	let verified: boolean
	if('toprf' in opts) {
		verified = await operator.groth16Verify(
			{ ...publicSignals, toprf: opts.toprf },
			proofData,
			logger
		)
	} else {
		// serialise to array of numbers for the ZK circuit
		verified = await operator.groth16Verify(
			// @ts-expect-error
			publicSignals,
			proofData,
			logger
		)
	}

	if(!verified) {
		throw new Error('invalid proof')
	}
}

/**
 * Generate a ZK witness for the symmetric encryption circuit.
 * This witness can then be used to generate a ZK proof,
 * using the operator's groth16Prove function.
 */
export async function generateZkWitness({
	algorithm,
	privateInput: { key },
	publicInput: { ciphertext, iv, offset },
}: GenerateWitnessOpts,
) {
	const {
		keySizeBytes,
		ivSizeBytes,
	} = CONFIG[algorithm]
	if(key.length !== keySizeBytes) {
		throw new Error(`key must be ${keySizeBytes} bytes`)
	}

	if(iv.length !== ivSizeBytes) {
		throw new Error(`iv must be ${ivSizeBytes} bytes`)
	}

	const startCounter = getCounterForChunk(algorithm, offset)
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext,
	)
	const plaintextArray = await decryptCiphertext({
		algorithm,
		key,
		iv,
		offset,
		ciphertext: ciphertextArray,
	})

	const witness: ZKProofInput = {
		key,
		nonce: iv,
		counter: startCounter,
		in: ciphertextArray,
		out: plaintextArray,
	}

	return { witness, plaintextArray }
}

export function getPublicSignals(
	{
		proof: { algorithm, plaintext },
		publicInput: { ciphertext, iv, offset },
	}: GetPublicSignalsOpts
): ZKProofPublicSignals {
	const startCounter = getCounterForChunk(algorithm, offset)
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext
	)

	if(ciphertextArray.length !== plaintext.length) {
		throw new Error('ciphertext and plaintext must be the same length')
	}

	return {
		nonce: iv,
		counter: startCounter,
		in: ciphertextArray,
		out: plaintext,
	}
}

function padCiphertextToChunkSize(
	alg: EncryptionAlgorithm,
	ciphertext: Uint8Array
) {
	const { chunkSize, bitsPerWord } = CONFIG[alg]

	const expectedSizeBytes = (chunkSize * bitsPerWord) / 8
	if(ciphertext.length > expectedSizeBytes) {
		throw new Error(`ciphertext must be <= ${expectedSizeBytes}b`)
	}

	if(ciphertext.length < expectedSizeBytes) {
		const arr = new Uint8Array(expectedSizeBytes).fill(0)
		arr.set(ciphertext)

		ciphertext = arr
	}

	return ciphertext
}

type DecryptCiphertextOpts = {
	algorithm: EncryptionAlgorithm
	key: Uint8Array
	iv: Uint8Array
	offset: number
	ciphertext: Uint8Array
}

async function decryptCiphertext({
	algorithm,
	key,
	iv,
	offset,
	ciphertext,
}: DecryptCiphertextOpts) {
	const { chunkSize, bitsPerWord, encrypt } = CONFIG[algorithm]
	const chunkSizeBytes = chunkSize * bitsPerWord / 8
	const startOffset = offset * chunkSizeBytes
	const inp = new Uint8Array(startOffset + ciphertext.length)
	inp.set(ciphertext, startOffset)

	const out = await encrypt({ key, iv, in: inp })
	return out.slice(startOffset)
}